// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

//! KLL Sketch Serialization Compatibility Tests
//!
//! These tests verify binary compatibility with Apache DataSketches implementations:
//! - Java (datasketches-java)
//! - C++ (datasketches-cpp)
//!
//! Test data is generated by the reference implementations and stored in:
//! `tests/serialization_test_data/`

mod common;

use std::fs;
use std::path::PathBuf;

use common::serialization_test_data;
use datasketches::kll::DEFAULT_K;
use datasketches::kll::KllSketch;

fn test_f32_file(path: PathBuf, expected_n: usize) {
    let bytes = fs::read(&path).unwrap();
    let sketch = KllSketch::<f32>::deserialize(&bytes).unwrap();

    assert_eq!(sketch.k(), DEFAULT_K, "wrong k in {}", path.display());
    assert_eq!(
        sketch.n() as usize,
        expected_n,
        "wrong n in {}",
        path.display()
    );
    assert_eq!(
        sketch.is_estimation_mode(),
        expected_n > DEFAULT_K as usize,
        "wrong estimation mode in {}",
        path.display()
    );
    assert_eq!(
        sketch.is_empty(),
        expected_n == 0,
        "wrong empty flag in {}",
        path.display()
    );

    if expected_n == 0 {
        assert!(sketch.min_item().is_none(), "min should be None");
        assert!(sketch.max_item().is_none(), "max should be None");
    } else {
        assert_eq!(
            sketch.min_item().cloned(),
            Some(1.0),
            "min item mismatch in {}",
            path.display()
        );
        assert_eq!(
            sketch.max_item().cloned(),
            Some(expected_n as f32),
            "max item mismatch in {}",
            path.display()
        );
    }
}

fn test_f64_file(path: PathBuf, expected_n: usize) {
    let bytes = fs::read(&path).unwrap();
    let sketch = KllSketch::<f64>::deserialize(&bytes).unwrap();

    assert_eq!(sketch.k(), DEFAULT_K, "wrong k in {}", path.display());
    assert_eq!(
        sketch.n() as usize,
        expected_n,
        "wrong n in {}",
        path.display()
    );
    assert_eq!(
        sketch.is_estimation_mode(),
        expected_n > DEFAULT_K as usize,
        "wrong estimation mode in {}",
        path.display()
    );
    assert_eq!(
        sketch.is_empty(),
        expected_n == 0,
        "wrong empty flag in {}",
        path.display()
    );

    if expected_n == 0 {
        assert!(sketch.min_item().is_none(), "min should be None");
        assert!(sketch.max_item().is_none(), "max should be None");
    } else {
        assert_eq!(
            sketch.min_item().cloned(),
            Some(1.0),
            "min item mismatch in {}",
            path.display()
        );
        assert_eq!(
            sketch.max_item().cloned(),
            Some(expected_n as f64),
            "max item mismatch in {}",
            path.display()
        );
    }
}

fn test_i64_file(path: PathBuf, expected_n: usize) {
    let bytes = fs::read(&path).unwrap();
    let sketch = KllSketch::<i64>::deserialize(&bytes).unwrap();

    assert_eq!(sketch.k(), DEFAULT_K, "wrong k in {}", path.display());
    assert_eq!(
        sketch.n() as usize,
        expected_n,
        "wrong n in {}",
        path.display()
    );
    assert_eq!(
        sketch.is_estimation_mode(),
        expected_n > DEFAULT_K as usize,
        "wrong estimation mode in {}",
        path.display()
    );
    assert_eq!(
        sketch.is_empty(),
        expected_n == 0,
        "wrong empty flag in {}",
        path.display()
    );

    if expected_n == 0 {
        assert!(sketch.min_item().is_none(), "min should be None");
        assert!(sketch.max_item().is_none(), "max should be None");
    } else {
        assert_eq!(
            sketch.min_item().cloned(),
            Some(1),
            "min item mismatch in {}",
            path.display()
        );
        assert_eq!(
            sketch.max_item().cloned(),
            Some(expected_n as i64),
            "max item mismatch in {}",
            path.display()
        );
    }
}

fn parse_string_value(value: &str) -> u64 {
    value
        .trim_start()
        .parse::<u64>()
        .expect("string value should be numeric")
}

fn test_string_file(path: PathBuf, expected_n: usize) {
    let bytes = fs::read(&path).unwrap();
    let sketch = KllSketch::<String>::deserialize(&bytes).unwrap();

    assert_eq!(sketch.k(), DEFAULT_K, "wrong k in {}", path.display());
    assert_eq!(
        sketch.n() as usize,
        expected_n,
        "wrong n in {}",
        path.display()
    );
    assert_eq!(
        sketch.is_estimation_mode(),
        expected_n > DEFAULT_K as usize,
        "wrong estimation mode in {}",
        path.display()
    );
    assert_eq!(
        sketch.is_empty(),
        expected_n == 0,
        "wrong empty flag in {}",
        path.display()
    );

    if expected_n == 0 {
        assert!(sketch.min_item().is_none(), "min should be None");
        assert!(sketch.max_item().is_none(), "max should be None");
    } else {
        let min_item = sketch.min_item().expect("missing min item");
        let max_item = sketch.max_item().expect("missing max item");
        assert_eq!(
            parse_string_value(min_item),
            1,
            "min item mismatch in {}",
            path.display()
        );
        assert_eq!(
            parse_string_value(max_item),
            expected_n as u64,
            "max item mismatch in {}",
            path.display()
        );
    }
}

#[test]
fn test_java_kll_float_compatibility() {
    let test_cases = [0, 1, 10, 100, 1000, 10000, 100000, 1000000];
    for n in test_cases {
        let filename = format!("kll_float_n{n}_java.sk");
        let path = serialization_test_data("java_generated_files", &filename);
        test_f32_file(path, n);
    }
}

#[test]
fn test_java_kll_double_compatibility() {
    let test_cases = [0, 1, 10, 100, 1000, 10000, 100000, 1000000];
    for n in test_cases {
        let filename = format!("kll_double_n{n}_java.sk");
        let path = serialization_test_data("java_generated_files", &filename);
        test_f64_file(path, n);
    }
}

#[test]
fn test_java_kll_long_compatibility() {
    let test_cases = [0, 1, 10, 100, 1000, 10000, 100000, 1000000];
    for n in test_cases {
        let filename = format!("kll_long_n{n}_java.sk");
        let path = serialization_test_data("java_generated_files", &filename);
        test_i64_file(path, n);
    }
}

#[test]
fn test_java_kll_string_compatibility() {
    let test_cases = [0, 1, 10, 100, 1000, 10000, 100000, 1000000];
    for n in test_cases {
        let filename = format!("kll_string_n{n}_java.sk");
        let path = serialization_test_data("java_generated_files", &filename);
        test_string_file(path, n);
    }
}

#[test]
fn test_cpp_kll_float_compatibility() {
    let test_cases = [0, 1, 10, 100, 1000, 10000, 100000, 1000000];
    for n in test_cases {
        let filename = format!("kll_float_n{n}_cpp.sk");
        let path = serialization_test_data("cpp_generated_files", &filename);
        test_f32_file(path, n);
    }
}

#[test]
fn test_cpp_kll_double_compatibility() {
    let test_cases = [0, 1, 10, 100, 1000, 10000, 100000, 1000000];
    for n in test_cases {
        let filename = format!("kll_double_n{n}_cpp.sk");
        let path = serialization_test_data("cpp_generated_files", &filename);
        test_f64_file(path, n);
    }
}

#[test]
fn test_cpp_kll_string_compatibility() {
    let test_cases = [0, 1, 10, 100, 1000, 10000, 100000, 1000000];
    for n in test_cases {
        let filename = format!("kll_string_n{n}_cpp.sk");
        let path = serialization_test_data("cpp_generated_files", &filename);
        test_string_file(path, n);
    }
}
